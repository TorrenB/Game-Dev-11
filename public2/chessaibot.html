<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Game</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #f8f8f8;
        }

        .chessboard {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            border: 2px solid #333;
            width: 600px;  /* Fixed width */
            height: 600px; /* Fixed height */
        }

        .square {
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 5em; /* Adjust size of chess pieces */
            transition: background-color 0.2s;
            width: 75px;  /* Fixed width for each square */
            height: 75px; /* Fixed height for each square */
        }

        .white {
            background-color: #ffffff;
        }

        .green {
            background-color: #2e8b8b;
        }

        .highlight {
            background-color: rgba(255, 255, 0, 0.5); /* Yellow with transparency */
        }

        .disabled {
            pointer-events: none; /* Disable pointer events for squares */
            opacity: 0.5; /* Show disabled state visually */
        }
    </style>
</head>

<body>
    <div class="chessboard" id="chessboard"></div>
    <script>
        const boardElement = document.getElementById('chessboard');

        const initialBoard = [
            ['♜', '♞', '♝', '♛', '♚', '♝', '♞', '♜'],
            ['♟', '♟', '♟', '♟', '♟', '♟', '♟', '♟'],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['♙', '♙', '♙', '♙', '♙', '♙', '♙', '♙'],
            ['♖', '♘', '♗', '♕', '♔', '♗', '♘', '♖'],
        ];

        let selectedSquare = null;
        let currentTurn = 'white'; // Track the current turn

        // Create the chessboard
        function createChessboard() {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.classList.add('square');
                    square.classList.add(((row + col) % 2 === 0) ? 'white' : 'green');

                    // Add chess piece if there is one
                    square.dataset.position = `${row},${col}`;
                    square.innerHTML = initialBoard[row][col];

                    // Add click event listener for selecting/moving pieces
                    square.addEventListener('click', () => handleSquareClick(square));
                    boardElement.appendChild(square);
                }
            }
            updateSquareState();
        }

        // Handle square click event
        function handleSquareClick(square) {
            if (!isPlayerTurn(square)) return; // If not player's turn, return

            const position = square.dataset.position.split(',').map(Number);
            
            if (selectedSquare) {
                // Moving the piece
                const selectedPiece = selectedSquare.innerHTML;
                const originalPosition = selectedSquare.dataset.position.split(',').map(Number);

                // Check if the move is valid
                if (isValidMove(selectedPiece, originalPosition, position)) {
                    square.innerHTML = selectedPiece; // Move piece
                    selectedSquare.innerHTML = ''; // Clear original square
                    // Change turn
                    currentTurn = currentTurn === 'white' ? 'black' : 'white';
                    updateSquareState(); // Update turn state
                }
                selectedSquare.classList.remove('highlight');
                selectedSquare = null; // Deselect
                clearHighlights(); // Clear move highlights
            } else {
                // Select the piece
                if (square.innerHTML && isCorrectTurn(square.innerHTML)) {
                    selectedSquare = square;
                    showValidMoves(square.innerHTML, position);
                }
            }
        }

        // Check if the clicked square is valid for the player's turn
        function isPlayerTurn(square) {
            return (currentTurn === 'white' && square.innerHTML.toUpperCase() === square.innerHTML) || 
                   (currentTurn === 'black' && square.innerHTML.toLowerCase() === square.innerHTML);
        }

        // Check if it is the correct turn
        function isCorrectTurn(piece) {
            return (currentTurn === 'white' && piece === piece.toUpperCase()) || 
                   (currentTurn === 'black' && piece === piece.toLowerCase());
        }

        // Show valid moves for the selected piece
        function showValidMoves(piece, position) {
            const row = position[0];
            const col = position[1];
            const moves = getMoves(piece, position);

            for (const move of moves) {
                const square = document.querySelector(`[data-position="${move[0]},${move[1]}"]`);
                if (square) {
                    square.classList.add('highlight');
                    square.removeEventListener('click', handleSquareClick); // Block normal clicks
                    square.addEventListener('click', () => handleMove(square, piece)); // Allow moving to highlighted
                }
            }
        }

        // Handle moving to highlighted square
        function handleMove(targetSquare, piece) {
            const originalSquare = selectedSquare;
            targetSquare.innerHTML = piece; // Move piece
            originalSquare.innerHTML = ''; // Clear original square
            // Change turn
            currentTurn = currentTurn === 'white' ? 'black' : 'white';
            updateSquareState(); // Update turn state

            originalSquare.classList.remove('highlight'); // Clear selection
            selectedSquare = null; // Deselect
            clearHighlights(); // Clear move highlights
        }

        // Update the state of the squares based on the current turn
        function updateSquareState() {
            const squares = document.querySelectorAll('.square');
            squares.forEach(square => {
                if (!isPlayerTurn(square)) {
                    square.classList.add('disabled');
                } else {
                    square.classList.remove('disabled');
                }
            });
        }

        // Clear highlighted squares
        function clearHighlights() {
            const highlighted = document.querySelectorAll('.highlight');
            highlighted.forEach(square => {
                square.classList.remove('highlight');
                square.removeEventListener('click', handleMove);
            });
        }

        // Get possible moves for a given piece type
        function getMoves(piece, position) {
            const moves = [];
            const row = position[0];
            const col = position[1];

            switch (piece.toLowerCase()) {
                case '♙': // White Pawn
                    if (row > 0) {
                        moves.push([row - 1, col]); // Move forward
                        if (row === 6) moves.push([row - 2, col]); // First move can move two squares
                    }
                    break;
                case '♟': // Black Pawn
                    if (row < 7) {
                        moves.push([row + 1, col]); // Move forward
                        if (row === 1) moves.push([row + 2, col]); // First move can move two squares
                    }
                    break;
                case '♖': // Rook
                case '♜':
                    for (let i = 1; i < 8; i++) {
                        if (addValidMoves(moves, row + i, col) || 
                            addValidMoves(moves, row - i, col) ||
                            addValidMoves(moves, row, col + i) ||
                            addValidMoves(moves, row, col - i)) {
                            break;  // Stop when another piece is found
                        }
                    }
                    break;
                case '♘': // Knight
                case '♞':
                    moves.push(
                        [row + 2, col + 1], [row + 2, col - 1], 
                        [row - 2, col + 1], [row - 2, col - 1],
                        [row + 1, col + 2], [row + 1, col - 2], 
                        [row - 1, col + 2], [row - 1, col - 2]
                    );
                    break;
                case '♗': // Bishop
                case '♝':
                    for (let i = 1; i < 8; i++) {
                        if (addValidMoves(moves, row + i, col + i) || 
                            addValidMoves(moves, row + i, col - i) ||
                            addValidMoves(moves, row - i, col + i) ||
                            addValidMoves(moves, row - i, col - i)) {
                            break;  // Stop when another piece is found
                        }
                    }
                    break;
                case '♕': // Queen
                case '♛':
                    for (let i = 1; i < 8; i++) {
                        if (addValidMoves(moves, row + i, col + i) || 
                            addValidMoves(moves, row + i, col - i) ||
                            addValidMoves(moves, row - i, col + i) ||
                            addValidMoves(moves, row - i, col - i) ||
                            addValidMoves(moves, row + i, col) ||
                            addValidMoves(moves, row - i, col) ||
                            addValidMoves(moves, row, col + i) ||
                            addValidMoves(moves, row, col - i)) {
                            break;  // Stop when another piece is found
                        }
                    }
                    break;
                case '♔': // King
                case '♚':
                    moves.push(
                        [row + 1, col], [row - 1, col], 
                        [row, col + 1], [row, col - 1], 
                        [row + 1, col + 1], [row + 1, col - 1], 
                        [row - 1, col + 1], [row - 1, col - 1]
                    );
                    break;
            }

            // Filter moves to ensure they don't land on own pieces
            return moves.filter(move => isWithinBounds(move) && !isOwnPiece(move));
        }

        function addValidMoves(moves, row, col) {
            const square = document.querySelector(`[data-position="${row},${col}"]`);
            if (!isWithinBounds([row, col])) return false; // Out of bounds
            if (square && square.innerHTML) {
                // If there's an own piece, stop checking further in this direction
                if (isOwnPiece(square.dataset.position.split(',').map(Number))) {
                    return true;
                }
                return false; // Stop if there's an opponent's piece
            }
            moves.push([row, col]);
            return false; // Continue moving
        }

        // Check if there is a piece of the current player at the target square
        function isOwnPiece(move) {
            const square = document.querySelector(`[data-position="${move[0]},${move[1]}"]`);
            const piece = square.innerHTML;

            // Check if the square contains a piece and determine if it's the same color
            if (piece) {
                if ((currentTurn === 'white' && piece === piece.toUpperCase()) || 
                    (currentTurn === 'black' && piece === piece.toLowerCase())) {
                    return true; // Own piece found
                }
            }
            return false; // No own piece
        }

        // Check if the move is within the board
        function isWithinBounds(move) {
            return move[0] >= 0 && move[0] < 8 && move[1] >= 0 && move[1] < 8;
        }

        // Initialize the chessboard
        createChessboard();
    </script>
</body>

</html>
